---
title : BFS - Nathan
tags : νΈλ¦¬, νƒμƒ‰
layout : article
author : Nathan Hong
mathjax : true
date : 2021-04-20
---


  
- [λ„λΉ„ μ°μ„  νƒμƒ‰](#λ„λΉ„-μ°μ„ -νƒμƒ‰)
  - [μν–‰ μμ„](#λ„λΉ„-μ°μ„ -νƒμƒ‰μ-μν–‰μμ„)
  - [κµ¬ν„ μ½”λ“](#λ„λΉ„-μ°μ„ μμ„-μ½”λ“)
  - [μμ  λ¬΄λ„¤](#λ¬Έμ )
  

## λ„λΉ„ μ°μ„  νƒμƒ‰

---

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ebb99dbd-b269-4673-95d9-57ec0cd5fa82/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ebb99dbd-b269-4673-95d9-57ec0cd5fa82/Untitled.png)

- μ‹μ‘ μ •μ μΌλ΅λ¶€ν„° μΈμ ‘ν• μ •μ λ“¤μ„ λ¨λ‘ μ°¨λ΅€λ΅ λ°©λ¬Έν•κ³  λ‚μ„,λ°©λ¬Έν–λ μ •μ μ„ μ‹μ‘μΌλ΅ ν•μ—¬ λ‹¤μ‹ μΈμ ‘ν• μ •μ λ“¤μ„ μ°¨λ΅€λ΅ λ°©λ¬Έν•λ” λ°©μ‹
- κ°€κΉμ΄ μ •μ λ“¤μ„ λ¨Όμ € λ°©λ¬Έν•κ³  λ©€λ¦¬μλ” μ •μ λ“¤μ€ λ‚μ¤‘μ— λ°©λ¬Έν•λ” μνλ°©λ²•
- μΈμ ‘ν• μ •μ λ“¤μ— λ€ν•΄μ„ μ°¨λ΅€λ΅ λ‹¤μ‹ λ„λΉ„ μ°μ„  νƒμƒ‰μ„ λ°λ³µν•΄μ•Όν•λ―€λ΅ μ„ μ…μ„ μ¶μ κµ¬μ΅°λ¥Ό κ°–λ” νλ¥Ό μ‚¬μ©

### λ„λΉ„ μ°μ„  νƒμƒ‰μ μν–‰μμ„

---

(1) μ‹μ‘ μ •μ  π‘£λ¥Ό κ²°μ •ν•μ—¬ λ°©λ¬Έν•λ‹¤.

(2) μ •μ  π‘£μ— μΈμ ‘ν• μ •μ λ“¤ μ¤‘μ—μ„ λ°©λ¬Έν•μ§€ μ•μ€ μ •μ μ„ μ°¨λ΅€λ΅ λ°©λ¬Έν•λ©΄μ„ νμ— enQueueν•λ‹¤.

(3) λ°©λ¬Έν•μ§€ μ•μ€ μΈμ ‘ν• μ •μ μ΄ μ—†μΌλ©΄, λ°©λ¬Έν–λ μ •μ μ—μ„ μΈμ ‘ν• μ •μ λ“¤μ„ λ‹¤μ‹ μ°¨λ΅€λ΅ λ°©λ¬Έν•κΈ° μ„ν•΄μ„ νμ—μ„ deQueueν•μ—¬ κµ¬ν• μ •μ 
μ—μ„ (2)λ¥Ό λ°λ³µν•λ‹¤.

(4) νκ°€ κ³µλ°±μ΄ λ  λ•κΉμ§€ (2)~(3)μ„ λ°λ³µν•λ‹¤

### λ„λΉ„ μ°μ„ μμ„ μ½”λ“

---

```java
private static void bfs(int r) {
        Queue<Integer> queue = new LinkedList<>();
        queue.add(r);
        visited[r] = true;

        while (!queue.isEmpty()) {
            int a = queue.poll();
            System.out.println(a);
            for (Integer s : graph.get(a)) {
                if (!visited[s]) {
                    visited[s] = true;
                    queue.add(s);
                }
            }
        }
    }
```

μ¶λ ¥κ²°κ³Ό

```java
1
3
2
7
6
5
4
9
8
```

## λ„λΉ„ μ°μ„  νƒμƒ‰ ν™μ©

---

- λ„λΉ„ μ°μ„  νƒμƒ‰μ κ²½μ° κ·Έλν”„ νƒμƒ‰μ λ§μ΄ ν™μ©λκ³  "κ²½λ΅"λ¬Έμ λ‚ μ‹λ®¬λ μ΄μ… λ¬Έμ μ— μμ£Ό λ‚μ¨λ‹¤.
- λ„λΉ„ μ°μ„  νƒμƒ‰μ κ²½μ° μµλ‹¨ κ±°λ¦¬ κµ¬ν•λ” λ¬Έμ λ΅ μμ£Ό ν™μ©λλ”λ°, μ•„λ λ°±μ¤€μ λ¬Έμ  μμ‹λ΅ ν•λ² ν’€μ–΄λ³΄μ.

### λ¬Έμ 

---

[2178λ²: λ―Έλ΅ νƒμƒ‰](https://www.acmicpc.net/problem/2178)

- NΓ—Mν¬κΈ°μ λ°°μ—΄λ΅ ν‘ν„λλ” λ―Έλ΅κ°€ μλ‹¤.
- λ―Έλ΅μ—μ„ 1μ€ μ΄λ™ν•  μ μλ” μΉΈμ„ λ‚νƒ€λ‚΄κ³ , 0μ€ μ΄λ™ν•  μ μ—†λ” μΉΈμ„ λ‚νƒ€λ‚Έλ‹¤.
    - μ΄λ¬ν• λ―Έλ΅κ°€ μ£Όμ–΄μ΅μ„ λ•, **(1, 1)μ—μ„ μ¶λ°ν•μ—¬ (N, M)μ μ„μΉλ΅ μ΄λ™ν•  λ• μ§€λ‚μ•Ό ν•λ” μµμ†μ μΉΈ μ**λ¥Ό κµ¬ν•λ” ν”„λ΅κ·Έλ¨μ„ μ‘μ„±ν•μ‹μ¤. ν• μΉΈμ—μ„ λ‹¤λ¥Έ μΉΈμΌλ΅ μ΄λ™ν•  λ•, μ„λ΅ μΈμ ‘ν• μΉΈμΌλ΅λ§ μ΄λ™ν•  μ μλ‹¤.
- μ„μ μμ—μ„λ” 15μΉΈμ„ μ§€λ‚μ•Ό (N, M)μ μ„μΉλ΅ μ΄λ™ν•  μ μλ‹¤. μΉΈμ„ μ…€ λ•μ—λ” μ‹μ‘ μ„μΉμ™€ λ„μ°© μ„μΉλ„ ν¬ν•¨ν•λ‹¤.

- μ„ λ¬Έμ λ¥Ό ν• μ¤„λ΅ μ”μ•½ν•λ©΄  **(1, 1)μ—μ„ μ¶λ°ν•μ—¬ (N, M)μ μ„μΉλ΅ μ΄λ™ν•  λ• μ§€λ‚μ•Ό ν•λ” μµμ†μ μΉΈ μ**λ¥Ό κµ¬ν•λ” ν”„λ΅κ·Έλ¨μ„ μ‘μ„±ν•λ” κ²ƒμ΄λ‹¤.

### λ¬Έμ  ν’€μ΄

---

- μ„λ΅ μΈμ ‘ν• μΉΈμΌλ΅λ§ μ΄λ™ κ°€λ¥ν•κΈ° λ•λ¬Έμ— μ„ μ•„λ μ¤λ¥Έμ½ μ™Όμ½ νƒμƒ‰ μ§„ν–‰.
- μ„ μ•„λ μ¤λ¥Έμ½ μ™Όμ½μ„ λ¨λ‘ νƒμƒ‰ν•λ©΄μ„ λ°©λ¬Έν•μ§€ μ•μ€ μΉΈμ—λ” ν„μ¬ μΉΈμ μ«μ + 1μ„ ν•λ©΄μ„ νƒμƒ‰μ„ μ§„ν–‰
- μµμΆ…μ μΌλ΅ N, MκΉμ§€ λ„λΉ„ μ°μ„  νƒμƒ‰μ„ ν•λ©΄μ„ μ§„ν–‰ν•λ©΄ N,Mμ—λ” μµμ† μΉΈμ μκ°€ μ ν€ μμ.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;

class Node {
    int x;
    int y;

    public Node(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

public class baekjoon2178 {

    public static int n;

    public static int m;

    public static int[][] map;

    public static boolean[][] visited;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] st = br.readLine().split(" ");
        n = Integer.parseInt(st[0]);
        m = Integer.parseInt(st[1]);
        map = new int[n+1][m+1];
        visited = new boolean[n+1][m+1];

        for (int i = 1; i <= n; i++) {
            String s = br.readLine();
            for (int j = 0; j < s.length(); j++) {
                map[i][j+1] = Integer.parseInt(String.valueOf(s.charAt(j)));
            }
        }

        bfs();
        System.out.println(map[n][m]);
    }

    public static void bfs() {
        int[] dx = {0, 0, 1, -1};
        int[] dy = {1, -1, 0, 0};
        Queue<Node> queue = new LinkedList<>();
        queue.add(new Node(1, 1));

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            int x = node.x;
            int y = node.y;

            for (int i = 0; i < 4; i++) {
                int mx = x + dx[i];
                int my = y + dy[i];
                if (mx > 0 && my > 0 && mx <= n && my <= m) {
                    if (!visited[mx][my] && map[mx][my] == 1) {
                        visited[mx][my] = true;
                        map[mx][my] = map[x][y] + 1;
                        queue.add(new Node(mx, my));
                    }
                }
            }
        }
    }
}
```